# Design: `find-dead-code` Command

## 1. Problem

Dead code exists in two forms:

1. **Unreferenced code** -- methods/classes never called from anywhere. Can be detected automatically.
2. **Assumption-based dead code** -- code that becomes unreachable when a certain expression's value is known (e.g., AB test winner determined, feature flag resolved, build config constant). Requires human input to provide the assumed value.

Both should be handled by a single `find-dead-code` command. For type 1, the tool can directly delete. For type 2, the tool provides a two-step workflow: scan/export assumption template, then analyze/delete after human annotation.

## 2. Workflow

```
                          ┌───────────────────────────┐
                          │  graphite find-dead-code   │
                          └──────────┬────────────────┘
                                     │
               ┌─────────────────────┼─────────────────────┐
               ▼                     ▼                     ▼
        No extra flags       --scan + --export       --assumptions
               │                     │                     │
               ▼                     ▼                     ▼
       Unreferenced code      Export assumption      Assumption-based
       detection (auto)       template (YAML)        dead code analysis
               │                     │                     │
               │                     ▼                     │
               │              Human annotates              │
               │              value: ??? → true            │
               │                     │                     │
               │                     └──────►──────────────┘
               │                                           │
               ▼                                           ▼
          Report or                                   Report or
          --delete                                    --delete
```

### Step-by-step

**Step 1: Scan & Export** (one-time per AB method)

```bash
graphite find-dead-code app.jar \
  --include com.example \
  -c com.example.AbClient -m getOption \
  --export-assumptions assumptions.yaml
```

Produces a YAML template with all discovered call sites, argument values, and propagation paths.

**Step 2: Human Annotation**

Edit `assumptions.yaml`, change `value: ???` to actual winner values.

**Step 3: Analyze & Delete**

```bash
graphite find-dead-code app.jar \
  --include com.example \
  --assumptions assumptions.yaml \
  --source-dir src/main/java \
  --delete
```

Finds all dead code (unreferenced + assumption-based), maps to source files, deletes.

## 3. Command Interface

```
graphite find-dead-code <input>

Positional:
  <input>                   JAR, WAR, Spring Boot JAR, or class directory

Common options:
  --include <pkg,...>       Package prefixes to include
  --exclude <pkg,...>       Package prefixes to exclude
  --include-libs            Include library JARs
  --lib-filter <pat,...>    Library JAR name filters
  -f, --format text|json    Output format (default: text)
  -v, --verbose             Verbose output

Unreferenced code options:
  --entry-points <regex,..> Additional entry point patterns (methods
                            matching these are considered reachable)
  --include-constructors    Include constructors in report

Scan & export options (reuse find-args conventions):
  -c, --class <name>        Target class name for scan (e.g., com.example.AbClient)
  -m, --method <name>       Target method name for scan (e.g., getOption)
  -r, --regex               Treat class and method names as regex patterns
  -p, --param-types <t,...> Parameter types filter (comma-separated)
  -i, --arg-index <n,...>   Argument indices to trace (0-based, default: 0)
  --scan-field <class> <field>
                            Scan usages of this field (class supports regex with -r)
  --export-assumptions <file>
                            Export assumption template to YAML file

Assumption-based analysis options:
  --assumptions <file>      Load assumptions from YAML file

Source & deletion options:
  --source-dir <dir,...>    Source directories (can specify multiple)
  --gradle-project <dir>    Auto-detect source dirs from Gradle project
  --delete                  Actually delete dead code (default: report only)
  --dry-run                 Preview deletions without modifying files
```

## 4. Assumption Config Format

### Exported template (before human annotation)

```yaml
# Generated by: graphite find-dead-code app.jar -c com.example.AbClient -m getOption --export-assumptions
# Method: com.example.AbClient.getOption

assumptions:
  - call:
      class: "com.example.AbClient"
      method: "getOption"
      args:
        0: 1001                              # resolved from AbTest.IMPROVE_CX_V1
    value: ???                               # <-- fill in: true / false
    call_sites:
      - caller: "com.example.CheckoutService.processOrder()"
        line: 42
        propagation: "AbTest.IMPROVE_CX_V1(1001) → param[0]"
      - caller: "com.example.CartService.getCart()"
        line: 78
        propagation: "const 1001 → local var → param[0]"

  - call:
      class: "com.example.AbClient"
      method: "getOption"
      args:
        0: 1002
    value: ???                               # <-- fill in: true / false
    call_sites:
      - caller: "com.example.PaymentService.pay()"
        line: 23
        propagation: "const 1002 → param[0]"

  - field:
      class: "com.example.BuildConfig"
      name: "DEBUG"
    value: ???                               # <-- fill in: true / false
    usages:
      - location: "com.example.Logger.log():15"
```

### After human annotation

```yaml
assumptions:
  - call:
      class: "com.example.AbClient"
      method: "getOption"
      args:
        0: 1001
    value: true                              # winner: treatment

  - call:
      class: "com.example.AbClient"
      method: "getOption"
      args:
        0: 1002
    value: false                             # winner: control

  - field:
      class: "com.example.BuildConfig"
      name: "DEBUG"
    value: false
```

`call_sites` / `usages` sections are informational -- the analysis engine ignores them.

### Matching semantics

An assumption `call: {class, method, args}` matches a `CallSiteNode` when:

1. `class` matches the callee's declaring class (exact or regex)
2. `method` matches the callee's method name (exact or regex)
3. For each entry in `args`: backward slice from that argument position resolves to the specified constant value (supports int, long, string, enum name, boolean)

An assumption `field: {class, name}` matches a `FieldNode` when:

1. `class` matches the field's declaring class
2. `name` matches the field name

## 5. Analysis Pipeline

### Phase 1: Unreferenced Code Detection

Existing capability. No framework changes needed.

```
All declared methods (graph.methods)
  minus  All called signatures (CallSiteNode.callee.signature)
  minus  Entry points (main, <clinit>, Spring lifecycle, user-specified)
  minus  Synthetic methods (lambda$, bridge$, values, valueOf)
  minus  Virtual dispatch candidates (same name+params called on any class)
  =      Unreferenced methods
```

Dead classes: classes where all non-synthetic, non-constructor methods are unreferenced.

**Action**: can delete directly without human input.

### Phase 2: Assumption-Based Dead Code Detection

Requires framework extensions (see Section 6).

```
For each assumption:
  ① Find matching nodes (call sites or field accesses)
  ② Mark matched node's value as the assumed constant
  ③ Propagate along ControlFlowEdges:
     - Constant reaches branch condition → determine jump direction
     - The other direction's branch is DEAD
  ④ Collect all nodes within dead branches
  ⑤ Extract CallSiteNodes from dead branches → dead method calls
  ⑥ Methods called ONLY from dead branches → transitively dead
  ⑦ Iterate ⑤-⑥ until convergence
```

#### Why step ③ works without compound boolean analysis

JVM bytecode compiles `&&` and `||` into nested if-statements:

```java
// Source
if (!abClient.getOption(1001) && "android".equalsIgnoreCase(request.getPlatform())) { ... }
```

```
// Bytecode (pseudo)
$option = abClient.getOption(1001)
if ($option) goto L_false          // Branch 1: negated check

$platform = request.getPlatform()
$match = "android".equalsIgnoreCase($platform)
if (!$match) goto L_false          // Branch 2: platform check

// true branch
...
L_false:
// false branch
```

Each sub-expression is a separate branch. Constant propagation through individual branches handles short-circuit logic automatically:

- Assumption: `getOption(1001) → true`
- Branch 1: `if (true) goto L_false` → always jumps → code after Branch 1 is unreachable
- Result: true branch and Branch 2 are dead, false branch is the only live path

No need to parse `&&`, `||`, `!` at the source level.

#### Convergence of transitive dead code (step ⑤-⑦)

```
Round 1: Dead branches contain calls to methods A, B, C
         A is called from elsewhere → alive
         B, C are called ONLY from dead branches → dead

Round 2: B calls D, E
         D is called from elsewhere → alive
         E is called ONLY from B → dead

Round 3: E calls nothing new → converged
```

Dead set = {B, C, E}

### Phase 3: Source Code Deletion

Requires source directory input.

#### Class name → source file mapping

```
com.example.order.OrderService
  → {source-dir}/com/example/order/OrderService.java
  → {source-dir}/com/example/order/OrderService.kt
```

Search each `--source-dir` and `--gradle-project` detected source set.

#### Deletion strategies

| Target | Detection | Strategy |
|--------|-----------|----------|
| Dead class | All methods unreferenced, or all methods in dead set | Delete entire `.java`/`.kt` file |
| Dead method | Unreferenced or in dead set | PSI: find `PsiMethod`/`KtNamedFunction` → `element.delete()` |
| Dead branch | Branch condition is assumed constant | PSI: find `PsiIfStatement`/`KtIfExpression` → replace with alive branch body |

#### Source manipulation via PSI

Use IntelliJ PSI as the unified AST engine for both Java and Kotlin. PSI handles
comments, annotations, whitespace, and formatting automatically.

**Dependencies** (in `graphite-cli` only):

```kotlin
// IntelliJ platform (PSI infrastructure)
"com.jetbrains.intellij.platform:core"           // PsiElement, PsiFile, etc.
"com.jetbrains.intellij.java:java-psi-impl"      // Java PSI: PsiMethod, PsiIfStatement
// Kotlin PSI (bundled with kotlin-compiler-embeddable)
"org.jetbrains.kotlin:kotlin-compiler-embeddable" // KtNamedFunction, KtIfExpression
```

**Initialization** (standalone, no IDE required):

```kotlin
// One-time setup for headless PSI environment
val project = createLightProject()   // IntelliJ's mock project for headless use
val psiManager = PsiManager.getInstance(project)
```

**Delete dead method**:

```
① PsiManager.findFile(sourceFile) → PsiJavaFile / KtFile
② Java: psiFile.classes[0].findMethodsByName(name, false)
         → match by parameter count/types
   Kotlin: psiFile.declarations.filterIsInstance<KtNamedFunction>()
           → match by name and parameters
③ psiMethod.delete()   ← removes method + annotations + Javadoc/KDoc automatically
④ Write modified PSI text back to file
```

**Delete dead branch**:

```
① Find PsiIfStatement / KtIfExpression at the target line number
② Determine alive branch:
   Java:  ifStmt.getThenBranch() or ifStmt.getElseBranch()
   Kotlin: ifExpr.then or ifExpr.`else`
③ ifStmt.replace(aliveBranch.statements)  ← replaces entire if/else with alive body
④ Write back
```

Example:
```java
// Before
if (abClient.getOption(1001)) {
    newCheckoutFlow();     // alive (assumption: true)
} else {
    oldCheckoutFlow();     // dead
}

// After
newCheckoutFlow();
```

**Advantages over brace-matching**:
- Handles strings/comments containing braces correctly
- Handles Kotlin expression bodies (`fun foo() = expr`)
- Annotations, Javadoc/KDoc removal is automatic
- Nested classes, lambdas, inner methods handled correctly
- Consistent API for both Java and Kotlin

## 6. Module Structure

Each CLI tool gets its own Gradle module and shadow JAR, minimizing dependencies per tool.

```
graphite/
├── graphite-core/              # Core framework (unchanged)
├── graphite-sootup/            # SootUp backend (unchanged)
├── graphite-cli-find-args/          # CLI: find-args
│   └── deps: picocli, gson, core, sootup
├── graphite-cli-find-endpoints/     # CLI: find-endpoints
│   └── deps: picocli, gson, core, sootup
└── graphite-cli-find-dead-code/     # CLI: find-dead-code
    └── deps: picocli, snakeyaml, PSI, kotlin-compiler, core, sootup
```

**Rationale**: `find-dead-code` requires IntelliJ PSI + kotlin-compiler-embeddable (~70MB+).
Bundling these into the same JAR as `find-args` would bloat the artifact for users who
don't need dead code analysis.

Each module has:
- `application` plugin with its own `mainClass`
- `shadow` plugin producing a standalone fat JAR
- Independent versioning via the root project's `-Pversion=` mechanism

**Migration**: The existing `graphite-cli` module is split into `graphite-cli-find-args` and
`graphite-cli-find-endpoints`. Package name stays `io.johnsonlee.graphite.cli` for all tools.

## 7. Framework Extensions Required

### 7.1 SootUpAdapter: Build ControlFlowEdges

**Current state**: `ControlFlowEdge` and `ControlFlowKind` types are defined in `graphite-core` but **never constructed** by the SootUpAdapter.

**Required**:

For each method body, the adapter needs to:

1. Iterate SootUp's `StmtGraph` control flow
2. For `JIfStmt`: extract the condition operand's NodeId, create:
   - `ControlFlowEdge(from=conditionNodeId, to=trueBranchFirstNodeId, kind=BRANCH_TRUE)`
   - `ControlFlowEdge(from=conditionNodeId, to=falseBranchFirstNodeId, kind=BRANCH_FALSE)`
3. For `JSwitchStmt`: create `SWITCH_CASE` and `SWITCH_DEFAULT` edges
4. For sequential flow: create `SEQUENTIAL` edges between statement nodes

The `from` of a branch edge MUST be the NodeId of the value used as the branch condition (LocalVariable, CallSiteNode, etc.), so that dataflow results can connect to branch information.

### 7.2 Core: BranchReachabilityAnalysis

New analysis engine in `graphite-core`:

```kotlin
class BranchReachabilityAnalysis(private val graph: Graph) {

    /**
     * Given a set of assumed-constant nodes, find all dead branches
     * and transitively dead methods.
     */
    fun analyze(assumptions: List<ConstantAssumption>): DeadCodeResult

}

data class ConstantAssumption(
    val nodeId: NodeId,          // the node whose value is assumed constant
    val value: Any               // the assumed constant value
)

data class DeadCodeResult(
    val deadBranches: List<DeadBranch>,
    val transitivelyDeadMethods: Set<MethodDescriptor>
)

data class DeadBranch(
    val conditionNodeId: NodeId,
    val deadKind: ControlFlowKind,   // BRANCH_TRUE or BRANCH_FALSE
    val lineNumber: Int?,
    val method: MethodDescriptor,
    val deadCallSites: List<CallSiteNode>
)
```

#### Internal algorithm

```
1. For each assumption (nodeId, value):
   a. Find outgoing ControlFlowEdges from nodeId
   b. If edge.kind == BRANCH_TRUE and value is truthy → true branch alive, false branch dead
   c. If edge.kind == BRANCH_TRUE and value is falsy → true branch dead, false branch alive
   d. Collect all nodes in the dead branch (traverse SEQUENTIAL edges until merge point)

2. Merge point detection:
   A node is a merge point if it has incoming ControlFlowEdges from BOTH
   the true and false branches (i.e., where the branches reconverge).

3. Collect dead CallSiteNodes from dead branches

4. Build reverse call map: callee → set of callers

5. Iterate to find transitively dead methods:
   dead_set = { methods called ONLY from dead branches }
   repeat:
     new_dead = { methods called ONLY from dead_set members }
     dead_set = dead_set ∪ new_dead
   until new_dead is empty
```

### 7.3 Core: ForwardSlice Enhancement

Current `forwardSlice` follows only `DataFlowEdge`. For assumption-based analysis, the scan/export phase needs to trace from a call site's return value to find where it ultimately reaches a branch condition.

**Required**: `forwardSlice` should optionally also report when a traced value reaches a `ControlFlowEdge.from` position (i.e., is used as a branch condition).

### 7.4 Dependencies

New dependencies for `graphite-cli-find-dead-code` only (`graphite-core` and `graphite-sootup` unchanged):

| Library | Purpose | Module |
|---------|---------|--------|
| `snakeyaml` or `kaml` | YAML parsing for assumption config | graphite-cli-find-dead-code |
| `com.jetbrains.intellij.platform:core` | PSI infrastructure | graphite-cli-find-dead-code |
| `com.jetbrains.intellij.java:java-psi-impl` | Java source parsing and manipulation | graphite-cli-find-dead-code |
| `org.jetbrains.kotlin:kotlin-compiler-embeddable` | Kotlin source parsing and manipulation | graphite-cli-find-dead-code |

## 8. Output Format

### Text report

```
Unreferenced dead code:
  Dead classes:
    com.example.LegacyService (5 methods)

  Dead methods:
    com.example.UserService
      - legacyMethod(String): void
      - unusedHelper(int, int): boolean

Assumption-based dead code:
  Assumption: AbClient.getOption(1001) -> true
    Dead branches:
      CheckoutService.processOrder():42 → false branch is dead
      CartService.getCart():78 → false branch is dead

    Transitively dead methods:
      - com.example.OldCheckoutFlow.execute(Order)
      - com.example.OldPaymentHandler.process(Payment)

  Assumption: BuildConfig.DEBUG -> false
    Dead branches:
      Logger.log():15 → true branch is dead

Summary:
  Total methods: 500
  Unreferenced: 23
  Dead classes: 2
  Assumption-dead branches: 3
  Transitively dead methods: 5
  Total dead code: 30 methods (6.0%)
```

### Deletion report (`--delete` or `--dry-run`)

```
[DELETE] src/main/java/com/example/LegacyService.java (dead class)
[DELETE] src/main/java/com/example/UserService.java:45-62 legacyMethod()
[DELETE] src/main/java/com/example/UserService.java:78-85 unusedHelper()
[CLEANUP] src/main/java/com/example/CheckoutService.java:42-55 remove false branch, keep true branch
[DELETE] src/main/java/com/example/OldCheckoutFlow.java (dead class, transitively dead)
[DELETE] src/main/java/com/example/OldPaymentHandler.java:15-30 process()
```

## 9. Implementation Phases

### Phase 0: Module restructuring

Split `graphite-cli` into per-tool modules.

Files:
- `settings.gradle.kts` -- replace `graphite-cli` with `graphite-cli-find-args`, `graphite-cli-find-endpoints`, `graphite-cli-find-dead-code`
- `graphite-cli-find-args/build.gradle.kts` -- application + shadow (picocli, gson)
- `graphite-cli-find-endpoints/build.gradle.kts` -- application + shadow (picocli, gson)
- `graphite-cli-find-dead-code/build.gradle.kts` -- application + shadow (picocli, snakeyaml, PSI)
- Move `FindArgumentsCommand.kt` → `graphite-cli-find-args/`
- Move `FindEndpointsCommand.kt` → `graphite-cli-find-endpoints/`
- Remove `graphite-cli/`
- Update root `build.gradle.kts` publishing config

### Phase 1: SootUpAdapter -- ControlFlowEdge construction

Build control flow edges from SootUp's StmtGraph. This is the foundation for all branch analysis.

Files:
- `graphite-sootup/.../SootUpAdapter.kt` -- add CFG edge construction
- `graphite-sootup/.../test/` -- test that edges are built correctly

### Phase 2: BranchReachabilityAnalysis

Core analysis engine that takes assumptions and finds dead branches.

Files:
- `graphite-core/.../analysis/BranchReachabilityAnalysis.kt` -- new analysis
- `graphite-core/.../test/` -- test branch analysis with simple if/else patterns

### Phase 3: CLI command -- unreferenced detection + scan/export

The `find-dead-code` command with:
- Unreferenced code detection (no framework changes needed)
- `--scan-method` / `--export-assumptions` workflow

Files:
- `graphite-cli-find-dead-code/.../FindDeadCodeCommand.kt` -- new command
- `graphite-cli-find-dead-code/.../Main.kt` -- entry point
- Add SnakeYAML dependency to `graphite-cli-find-dead-code/build.gradle.kts`

### Phase 4: CLI command -- assumption-based analysis

Load assumptions from YAML, run BranchReachabilityAnalysis, report results.

Files:
- `graphite-cli-find-dead-code/.../FindDeadCodeCommand.kt` -- add assumption loading and analysis

### Phase 5: Source code deletion

Map dead code to source files, implement deletion strategies via PSI.

Files:
- `graphite-cli-find-dead-code/.../SourceCodeEditor.kt` -- new: PSI-based source manipulation
- `graphite-cli-find-dead-code/.../FindDeadCodeCommand.kt` -- add `--delete` / `--dry-run` / `--source-dir`
- Add PSI + kotlin-compiler-embeddable dependencies

### Phase 6: Kotlin support & edge cases

- `.kt` file handling (`fun` keyword, expression body `=`)
- Inner classes, companion objects
- Multi-module Gradle projects
